######################
üßµ What is a Thread?
######################
‚û§ A thread is the smallest unit of execution within a process
‚û§ It represents an independent path of execution inside a program
‚û§ Multiple threads can run concurrently within the same process

‚öôÔ∏è Thread vs Process (Core Idea)
***********************************
‚û§ A process is an independent program in execution
‚û§ A thread is a lightweight sub-task of a process
‚û§ All threads of a process share the same memory (heap)

üß† What Does a Thread Have?
******************************
‚û§ Thread ID ‚Äì uniquely identifies a thread
‚û§ Program Counter ‚Äì keeps track of current instruction
‚û§ Stack ‚Äì stores local variables & method calls
‚û§ Thread state ‚Äì new, runnable, running, blocked, etc.

‚û§ What is Shared Among Threads?
‚û§ Heap memory
‚û§ Static variables
‚û§ Open files & resources

üöÄ Why Threads Are Called ‚ÄúLightweight‚Äù?
********************************************
‚û§ Creating a thread is faster than creating a process
‚û§ Context switching between threads is cheaper
‚û§ Threads use less memory compared to processes

üåç Real-World Example
***********************
‚û§ In a browser:
‚û§ One thread loads a webpage
‚û§ Another thread plays a video
‚û§ Another thread handles user input

üìå Advantages of Using Threads
********************************
‚û§ Better CPU utilization
‚û§ Improved application responsiveness
‚û§ Enables parallel execution on multi-core systems

‚ö†Ô∏è Challenges with Threads (Interview Important)
***************************************************
‚û§ Race condition due to shared memory
‚û§ Deadlock if threads wait indefinitely
‚û§ Complex debugging

üéØ Interview One-Liner (Must Remember)
*****************************************
‚û§ A thread is the smallest unit of execution that runs independently within a process and shares the process memory.

#############################################
üßµ Different Ways to Create Threads in Java
#############################################
In Java, threads can be created in multiple ways, but interviewers mainly expect 4 standard approaches.

üß© 1. Extending Thread Class
*******************************
‚û§ Create a class that extends Thread
‚û§ Override the run() method
‚û§ Call start() to begin execution

class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // creates new thread & calls run()
    }
}

‚û§ Key Points
‚û§ run() contains the task
‚û§ start() creates a new call stack
‚û§ Direct call to run() ‚Üí no new thread

‚û§ Limitations (Interview Trap)
‚û§ Java does not support multiple inheritance
‚û§ Cannot extend any other class

üß© 2. Implementing Runnable Interface ‚≠ê (Most Preferred)
***********************************************************
‚û§ Create a class that implements Runnable
‚û§ Override run() method
‚û§ Pass Runnable object to Thread constructor

class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Test {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}

‚û§ Why This is Better Than Extending Thread?
‚û§ Supports multiple inheritance
‚û§ Separates task logic from thread management
‚û§ Better object-oriented design

‚û§ Interview Verdict
‚û§ ‚≠ê Best approach for most cases

üß© 3. Using Callable Interface (With ExecutorService)
******************************************************
‚û§ Callable is used when:
‚û§ Thread needs to return a value
‚û§ Thread may throw checked exception

Callable<Integer> task = () -> {
    return 10;
};

ExecutorService service = Executors.newSingleThreadExecutor();
Future<Integer> future = service.submit(task);

System.out.println(future.get());
service.shutdown();

‚û§ Key Differences from Runnable
‚û§ Callable ‚Üí returns result
‚û§ Runnable ‚Üí returns nothing (void)
‚û§ Callable ‚Üí can throw checked exceptions

üß© 4. Using Executor Framework (Modern Approach) ‚≠ê‚≠ê‚≠ê
*********************************************************
‚û§ Java 5 introduced Executor Framework
‚û§ Thread creation & management handled by framework
‚û§ Uses thread pools

ExecutorService executor = Executors.newFixedThreadPool(2);

executor.execute(() -> {
    System.out.println("Thread executed by executor");
});

executor.shutdown();

‚û§ Why This Is Industry Standard?
‚û§ Reuses threads (better performance)
‚û§ Controls number of threads
‚û§ Prevents resource exhaustion

üß† Summary Table (Interview Gold)
************************************
########################################################################
| Way                | Returns Value | Preferred | Notes               |
| ------------------ | ------------- | --------- | ------------------- |
| Extend Thread      | ‚ùå             | ‚ùå      | Poor design         |
| Implement Runnable | ‚ùå             | ‚úÖ      | Best basic approach |
| Callable           | ‚úÖ             | ‚úÖ      | When result needed  |
| Executor Framework | ‚úÖ             | ‚≠ê‚≠ê‚≠ê | Production ready    |
########################################################################

üéØ Interview One-Liner
************************
‚û§ Threads in Java can be created using Thread class, Runnable interface, Callable interface, and Executor framework.

‚ö†Ô∏è Common Interview Traps
***************************
‚û§ Calling run() instead of start()
‚û§ Creating too many threads manually
‚û§ Ignoring thread pool concept

##########################
üßµ Thread States in Java
##########################
In Java, a thread can exist in 6 predefined states, represented by the Thread.State enum.

‚öôÔ∏è 1. NEW
***********
‚û§ Thread is created but not started
‚û§ start() method is not yet called

Thread t = new Thread();
System.out.println(t.getState()); // NEW

‚û§ Important Point
‚û§ No system resources are allocated yet

üöÄ 2. RUNNABLE
*****************
‚û§ Thread is ready to run and waiting for CPU
‚û§ Includes both:
‚û§ ‚û§ Ready state
‚û§ ‚û§ Running state

t.start();
System.out.println(t.getState()); // RUNNABLE

‚û§ Interview Trap
‚û§ Java does not have separate READY and RUNNING states

üîí 3. BLOCKED
****************
‚û§ Thread is waiting to acquire a monitor lock
‚û§ Occurs when:
‚û§ ‚û§ Thread tries to enter a synchronized block
‚û§ ‚û§ Lock is held by another thread

synchronized(obj) {
    // if lock is unavailable ‚Üí BLOCKED
}

‚è≥ 4. WAITING
***************
‚û§ Thread waits indefinitely for another thread‚Äôs action
‚û§ Entered by calling:
‚û§ ‚û§ wait()
‚û§ ‚û§ join() (without timeout)
‚û§ ‚û§ LockSupport.park()

obj.wait();     // WAITING
t.join();       // WAITING

‚û§ Key Point
‚û§ Thread will resume only after notification

‚è±Ô∏è 5. TIMED_WAITING
*********************
‚û§ Thread waits for a specified time period
‚û§ Entered by calling:
‚û§ ‚û§ sleep(time)
‚û§ ‚û§ wait(time)
‚û§ ‚û§ join(time)

Thread.sleep(1000); // TIMED_WAITING

‚ò†Ô∏è 6. TERMINATED (DEAD)
*************************
‚û§ Thread has completed execution
‚û§ run() method has finished
‚û§ Thread cannot be restarted

// After run() ends
System.out.println(t.getState()); // TERMINATED

üîÑ Thread State Lifecycle (Flow)
=================================
‚û§ NEW ‚Üí RUNNABLE
‚û§ RUNNABLE ‚Üí BLOCKED / WAITING / TIMED_WAITING
‚û§ WAITING / TIMED_WAITING ‚Üí RUNNABLE
‚û§ RUNNABLE ‚Üí TERMINATED

üìå Quick Comparison Table
***************************
########################################
| State         | Meaning              |
| ------------- | -------------------- |
| NEW           | Thread created       |
| RUNNABLE      | Ready or running     |
| BLOCKED       | Waiting for lock     |
| WAITING       | Waiting indefinitely |
| TIMED_WAITING | Waiting with time    |
| TERMINATED    | Execution completed  |
########################################

‚ö†Ô∏è Interview Traps
********************
‚û§ sleep() ‚Üí does not release lock
‚û§ wait() ‚Üí releases lock
‚û§ BLOCKED ‚â† WAITING

üéØ Interview One-Liner
***********************
‚û§ Java thread lifecycle consists of six states: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, and TERMINATED.