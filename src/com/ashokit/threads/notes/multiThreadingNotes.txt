######################
ğŸ§µ What is a Thread?
######################
â¤ A thread is the smallest unit of execution within a process
â¤ It represents an independent path of execution inside a program
â¤ Multiple threads can run concurrently within the same process

âš™ï¸ Thread vs Process (Core Idea)
***********************************
â¤ A process is an independent program in execution
â¤ A thread is a lightweight sub-task of a process
â¤ All threads of a process share the same memory (heap)

ğŸ§  What Does a Thread Have?
******************************
â¤ Thread ID â€“ uniquely identifies a thread
â¤ Program Counter â€“ keeps track of current instruction
â¤ Stack â€“ stores local variables & method calls
â¤ Thread state â€“ new, runnable, running, blocked, etc.

â¤ What is Shared Among Threads?
â¤ Heap memory
â¤ Static variables
â¤ Open files & resources

ğŸš€ Why Threads Are Called â€œLightweightâ€?
********************************************
â¤ Creating a thread is faster than creating a process
â¤ Context switching between threads is cheaper
â¤ Threads use less memory compared to processes

ğŸŒ Real-World Example
***********************
â¤ In a browser:
â¤ One thread loads a webpage
â¤ Another thread plays a video
â¤ Another thread handles user input

ğŸ“Œ Advantages of Using Threads
********************************
â¤ Better CPU utilization
â¤ Improved application responsiveness
â¤ Enables parallel execution on multi-core systems

âš ï¸ Challenges with Threads (Interview Important)
***************************************************
â¤ Race condition due to shared memory
â¤ Deadlock if threads wait indefinitely
â¤ Complex debugging

ğŸ¯ Interview One-Liner (Must Remember)
*****************************************
â¤ A thread is the smallest unit of execution that runs independently within a process and shares the process memory.

#############################################
ğŸ§µ Different Ways to Create Threads in Java
#############################################
In Java, threads can be created in multiple ways, but interviewers mainly expect 4 standard approaches.

ğŸ§© 1. Extending Thread Class
*******************************
â¤ Create a class that extends Thread
â¤ Override the run() method
â¤ Call start() to begin execution

class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // creates new thread & calls run()
    }
}

â¤ Key Points
â¤ run() contains the task
â¤ start() creates a new call stack
â¤ Direct call to run() â†’ no new thread

â¤ Limitations (Interview Trap)
â¤ Java does not support multiple inheritance
â¤ Cannot extend any other class

ğŸ§© 2. Implementing Runnable Interface â­ (Most Preferred)
***********************************************************
â¤ Create a class that implements Runnable
â¤ Override run() method
â¤ Pass Runnable object to Thread constructor

class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Test {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}

â¤ Why This is Better Than Extending Thread?
â¤ Supports multiple inheritance
â¤ Separates task logic from thread management
â¤ Better object-oriented design

â¤ Interview Verdict
â¤ â­ Best approach for most cases

ğŸ§© 3. Using Callable Interface (With ExecutorService)
******************************************************
â¤ Callable is used when:
â¤ Thread needs to return a value
â¤ Thread may throw checked exception

Callable<Integer> task = () -> {
    return 10;
};

ExecutorService service = Executors.newSingleThreadExecutor();
Future<Integer> future = service.submit(task);

System.out.println(future.get());
service.shutdown();

â¤ Key Differences from Runnable
â¤ Callable â†’ returns result
â¤ Runnable â†’ returns nothing (void)
â¤ Callable â†’ can throw checked exceptions

ğŸ§© 4. Using Executor Framework (Modern Approach) â­â­â­
*********************************************************
â¤ Java 5 introduced Executor Framework
â¤ Thread creation & management handled by framework
â¤ Uses thread pools

ExecutorService executor = Executors.newFixedThreadPool(2);

executor.execute(() -> {
    System.out.println("Thread executed by executor");
});

executor.shutdown();

â¤ Why This Is Industry Standard?
â¤ Reuses threads (better performance)
â¤ Controls number of threads
â¤ Prevents resource exhaustion

ğŸ§  Summary Table (Interview Gold)
************************************
########################################################################
| Way                | Returns Value | Preferred | Notes               |
| ------------------ | ------------- | --------- | ------------------- |
| Extend Thread      | âŒ             | âŒ      | Poor design         |
| Implement Runnable | âŒ             | âœ…      | Best basic approach |
| Callable           | âœ…             | âœ…      | When result needed  |
| Executor Framework | âœ…             | â­â­â­ | Production ready    |
########################################################################

ğŸ¯ Interview One-Liner
************************
â¤ Threads in Java can be created using Thread class, Runnable interface, Callable interface, and Executor framework.

âš ï¸ Common Interview Traps
***************************
â¤ Calling run() instead of start()
â¤ Creating too many threads manually
â¤ Ignoring thread pool concept