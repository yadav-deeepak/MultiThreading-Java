######################
ğŸ§µ What is a Thread?
######################
â¤ A thread is the smallest unit of execution within a process
â¤ It represents an independent path of execution inside a program
â¤ Multiple threads can run concurrently within the same process

âš™ï¸ Thread vs Process (Core Idea)
***********************************
â¤ A process is an independent program in execution
â¤ A thread is a lightweight sub-task of a process
â¤ All threads of a process share the same memory (heap)

ğŸ§  What Does a Thread Have?
******************************
â¤ Thread ID â€“ uniquely identifies a thread
â¤ Program Counter â€“ keeps track of current instruction
â¤ Stack â€“ stores local variables & method calls
â¤ Thread state â€“ new, runnable, running, blocked, etc.

â¤ What is Shared Among Threads?
â¤ Heap memory
â¤ Static variables
â¤ Open files & resources

ğŸš€ Why Threads Are Called â€œLightweightâ€?
********************************************
â¤ Creating a thread is faster than creating a process
â¤ Context switching between threads is cheaper
â¤ Threads use less memory compared to processes

ğŸŒ Real-World Example
***********************
â¤ In a browser:
â¤ One thread loads a webpage
â¤ Another thread plays a video
â¤ Another thread handles user input

ğŸ“Œ Advantages of Using Threads
********************************
â¤ Better CPU utilization
â¤ Improved application responsiveness
â¤ Enables parallel execution on multi-core systems

âš ï¸ Challenges with Threads (Interview Important)
***************************************************
â¤ Race condition due to shared memory
â¤ Deadlock if threads wait indefinitely
â¤ Complex debugging

ğŸ¯ Interview One-Liner (Must Remember)
*****************************************
â¤ A thread is the smallest unit of execution that runs independently within a process and shares the process memory.

#############################################
ğŸ§µ Different Ways to Create Threads in Java
#############################################
In Java, threads can be created in multiple ways, but interviewers mainly expect 4 standard approaches.

ğŸ§© 1. Extending Thread Class
*******************************
â¤ Create a class that extends Thread
â¤ Override the run() method
â¤ Call start() to begin execution

class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // creates new thread & calls run()
    }
}

â¤ Key Points
â¤ run() contains the task
â¤ start() creates a new call stack
â¤ Direct call to run() â†’ no new thread

â¤ Limitations (Interview Trap)
â¤ Java does not support multiple inheritance
â¤ Cannot extend any other class

ğŸ§© 2. Implementing Runnable Interface â­ (Most Preferred)
***********************************************************
â¤ Create a class that implements Runnable
â¤ Override run() method
â¤ Pass Runnable object to Thread constructor

class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Test {
    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        t1.start();
    }
}

â¤ Why This is Better Than Extending Thread?
â¤ Supports multiple inheritance
â¤ Separates task logic from thread management
â¤ Better object-oriented design

â¤ Interview Verdict
â¤ â­ Best approach for most cases

ğŸ§© 3. Using Callable Interface (With ExecutorService)
******************************************************
â¤ Callable is used when:
â¤ Thread needs to return a value
â¤ Thread may throw checked exception

Callable<Integer> task = () -> {
    return 10;
};

ExecutorService service = Executors.newSingleThreadExecutor();
Future<Integer> future = service.submit(task);

System.out.println(future.get());
service.shutdown();

â¤ Key Differences from Runnable
â¤ Callable â†’ returns result
â¤ Runnable â†’ returns nothing (void)
â¤ Callable â†’ can throw checked exceptions

ğŸ§© 4. Using Executor Framework (Modern Approach) â­â­â­
*********************************************************
â¤ Java 5 introduced Executor Framework
â¤ Thread creation & management handled by framework
â¤ Uses thread pools

ExecutorService executor = Executors.newFixedThreadPool(2);

executor.execute(() -> {
    System.out.println("Thread executed by executor");
});

executor.shutdown();

â¤ Why This Is Industry Standard?
â¤ Reuses threads (better performance)
â¤ Controls number of threads
â¤ Prevents resource exhaustion

ğŸ§  Summary Table (Interview Gold)
************************************
########################################################################
| Way                | Returns Value | Preferred | Notes               |
| ------------------ | ------------- | --------- | ------------------- |
| Extend Thread      | âŒ             | âŒ      | Poor design         |
| Implement Runnable | âŒ             | âœ…      | Best basic approach |
| Callable           | âœ…             | âœ…      | When result needed  |
| Executor Framework | âœ…             | â­â­â­ | Production ready    |
########################################################################

ğŸ¯ Interview One-Liner
************************
â¤ Threads in Java can be created using Thread class, Runnable interface, Callable interface, and Executor framework.

âš ï¸ Common Interview Traps
***************************
â¤ Calling run() instead of start()
â¤ Creating too many threads manually
â¤ Ignoring thread pool concept

##########################
ğŸ§µ Thread States in Java
##########################
In Java, a thread can exist in 6 predefined states, represented by the Thread.State enum.

âš™ï¸ 1. NEW
***********
â¤ Thread is created but not started
â¤ start() method is not yet called

Thread t = new Thread();
System.out.println(t.getState()); // NEW

â¤ Important Point
â¤ No system resources are allocated yet

ğŸš€ 2. RUNNABLE
*****************
â¤ Thread is ready to run and waiting for CPU
â¤ Includes both:
â¤ â¤ Ready state
â¤ â¤ Running state

t.start();
System.out.println(t.getState()); // RUNNABLE

â¤ Interview Trap
â¤ Java does not have separate READY and RUNNING states

ğŸ”’ 3. BLOCKED
****************
â¤ Thread is waiting to acquire a monitor lock
â¤ Occurs when:
â¤ â¤ Thread tries to enter a synchronized block
â¤ â¤ Lock is held by another thread

synchronized(obj) {
    // if lock is unavailable â†’ BLOCKED
}

â³ 4. WAITING
***************
â¤ Thread waits indefinitely for another threadâ€™s action
â¤ Entered by calling:
â¤ â¤ wait()
â¤ â¤ join() (without timeout)
â¤ â¤ LockSupport.park()

obj.wait();     // WAITING
t.join();       // WAITING

â¤ Key Point
â¤ Thread will resume only after notification

â±ï¸ 5. TIMED_WAITING
*********************
â¤ Thread waits for a specified time period
â¤ Entered by calling:
â¤ â¤ sleep(time)
â¤ â¤ wait(time)
â¤ â¤ join(time)

Thread.sleep(1000); // TIMED_WAITING

â˜ ï¸ 6. TERMINATED (DEAD)
*************************
â¤ Thread has completed execution
â¤ run() method has finished
â¤ Thread cannot be restarted

// After run() ends
System.out.println(t.getState()); // TERMINATED

ğŸ”„ Thread State Lifecycle (Flow)
=================================
â¤ NEW â†’ RUNNABLE
â¤ RUNNABLE â†’ BLOCKED / WAITING / TIMED_WAITING
â¤ WAITING / TIMED_WAITING â†’ RUNNABLE
â¤ RUNNABLE â†’ TERMINATED

ğŸ“Œ Quick Comparison Table
***************************
########################################
| State         | Meaning              |
| ------------- | -------------------- |
| NEW           | Thread created       |
| RUNNABLE      | Ready or running     |
| BLOCKED       | Waiting for lock     |
| WAITING       | Waiting indefinitely |
| TIMED_WAITING | Waiting with time    |
| TERMINATED    | Execution completed  |
########################################

âš ï¸ Interview Traps
********************
â¤ sleep() â†’ does not release lock
â¤ wait() â†’ releases lock
â¤ BLOCKED â‰  WAITING

ğŸ¯ Interview One-Liner
***********************
â¤ Java thread lifecycle consists of six states: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, and TERMINATED.

#######################################################
ğŸ§µ Can We Use the Same Thread Object Multiple Times?
#######################################################
â¤ NO, a Thread object cannot be started more than once in Java

âŒ What Happens If We Try?
*****************************
â¤ Calling start() on the same thread object again results in:
â¤ â¤ java.lang.IllegalThreadStateException

class Test {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            System.out.println("Running...");
        });

        t.start();
        t.start(); // âŒ Runtime Exception
    }
}

âš ï¸ Reason (Interview Important)
*********************************
â¤ Once start() is called:
â¤ â¤ Thread moves from NEW â†’ RUNNABLE
â¤ â¤ Executes run()
â¤ â¤ Ends in TERMINATED state

â¤ A terminated thread cannot be restarted

ğŸ” Common Confusion (Important Clarification)
***********************************************
â¤ Thread object cannot be reused
â¤ Runnable object CAN be reused

Runnable task = () -> {
    System.out.println("Task executed");
};

Thread t1 = new Thread(task);
Thread t2 = new Thread(task);

t1.start();
t2.start(); // âœ… Allowed

â¤ Same task, different thread objects

ğŸ§  Interview Trick Question
******************************
Q: Can we restart a thread after completion?
â¤ Answer: âŒ No, thread lifecycle does not allow restart

ğŸ“Œ Best Practice (Production Level)
*************************************
â¤ Do not manage threads manually
â¤ Use Executor Framework to execute tasks multiple times

ExecutorService executor = Executors.newFixedThreadPool(2);
executor.execute(task);
executor.execute(task);
executor.shutdown();

ğŸ¯ Interview One-Liner
*************************
â¤ A thread object can be started only once; attempting to restart it causes IllegalThreadStateException.