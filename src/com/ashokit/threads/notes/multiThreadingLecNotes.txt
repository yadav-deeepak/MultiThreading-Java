######################
‚ùÑÔ∏è What is Thread ?
######################
‚û§ Thread is an independent path of execution within a same program.
‚û§ There are 3 ways to create a thread 
1. Extends Thread class 
2. Implementing Runnable Interface

‚û§ start() method is responsible for creating the independent path of execution.
‚û§ The independent path of execution starts from the run() method.

##########################
‚ùÑÔ∏è Ways to create Thread 
##########################
‚û§ There are 3 ways to create a thread 
1. By extending Thread class 
2. By implementing runnable interface 
3. Implementing callable interface 

üëâ Extending Thread class 
***************************
‚û§ When we extend Thread class it will be calling the no args constructor of the Thread class from there we are getting the thread-ThreadNumber 
‚û§ So we are getting the thread number from there.
public Thread(){
    this(null, null, "Thread-"+nextThreadNum(), 0);
}
// The nextThreadNum() method is just incrementing the count of the threads and returning the thread number.
‚û§ In the Thread class there is a method called start() and this method is responsible to create the independent path of execution . So when we write t1.start() this will create the independent path of execution and start the exection of that from the run() method.
‚û§ So the starting point of every thread is run() method so we need to override it according to our need. If we dont override it then it will go to the run() of the thread class and run whatever is written inside the run() of Thread class.
‚û§ Calling the start() is not same as calling the run()
Eg: t1.start(); //This will create an independent path of execution and run the run().
t1.run(); //This will not create an independent path of execution will directly call the run() and execute it.
if we call the run() then it will not create the independent path of execution it will run the normally.
‚û§ If you want to keep the name for your thread then there are two ways to do it :

1. Using the constructor and passing name of thread while creating the object .
Eg: ThreadExample t1 = new ThreadExample("First Thread");

2. Using the setName() method 
Eg: t1.setName("asdf");
‚û§ We need to call the setName() before calling the start() always , it will not have any impact if we call it after the start() method. 

üëâ By implementing Runnable Interface 
****************************************
‚û§ Thread class internally implements the Runnable interface.
‚û§ The Runnable interface has only one abstract method run(). Which is overriden by the Thread class because it implements the runnable interface 
‚û§ So when we create thread using the runnable interface then we also need to override the run() method .
‚û§ Now we need to call the start() of the thread class and since it is an instance method we need to create thread class object first then only we can call the start() so how do we do this when we are creating a thread by implementing Runnable interface?? 
So we have a constructor in the Thread class which takes Runnable as parameter using this we will create the object of the thread class.
‚û§ We will create the object of the class that implemented Runnable interface and then we will pass it to the Thread class constructor this will create a Thread class object for us.

Example: 
----------
public class ThreadExampleUsingRunnable implements Runnable{

	@Override
	public void run() {
		// TODO Auto-generated method stub
		System.out.println("Hi");
	}
	
	public static void main(String[] args) {
		ThreadExampleUsingRunnable tr = new ThreadExampleUsingRunnable();
		Thread t = new Thread(tr);
		
		Thread t1 = new Thread(new ThreadExampleUsingRunnable());
		
		t.start();
		t1.start();
	}

}

##################
‚ùÑÔ∏è Thread States 
##################
‚û§ There are differnt states in threads 
1. New : A thread can be called to be in new state only when the thread object is created start() is not called yet.

üëâ NOTE: 
----------
‚û§ How many threads will run at a time will depend upon the operating system or our system configuration its not like that we have created 1000 threads and all threads will run at the same time it depends on the system.

2. Runnable : When we start the thread then we can say all the threads are in the runnable pool from there operating system will take some of the thread and will start running them .

3. Running : The thread which is executing the run() is said to be in the running state .

4. Dead : After the execution of the run() we can say that the thread is in the dead state.

5. Wait 
6. Sleep
7. Blocked 

üìÖ Can we use the same thread object multiple times ?
#######################################################
‚û§ So the basic idea here is that if a task takes 1 hr to be completed in a single thread and we want to reduce the execution time then we can take 20 threads and complete the same task in 20 min but the problem here is that we are creating 20 new thread objects which will occupy a lot of memory so to solve this problem.
‚û§ The thread object is free once it complete the execution of the run() so why dont we reuse that to solve this problem 
Eg: 
ThreadExample t1 = new ThreadExample("First Thread");
t1.start(); 
t1.start(); 
// But when we do this it will give us the illegalThreadState exception.
‚û§ So we are getting this execption because t1 has not yet finished the run() execution and how jvm knows this inside the start() there is a variable threadStatus which is checked everytime start() is called and it tells us about the status of the thread.
‚û§ So whenever we try to use a thread whose state is dead it will give us illegalThreadState exception. 
‚û§ So this means that we cant reuse the thread again .

‚û§ So the disadvantage of the thread is we cant reuse the thread object after the completion of run() method and in order to overcome this we are going to use thread pool.
‚û§ In normal thread we can't reuse the thread but using thread pool we can reuse the thread.

‚û§ At any point of time which thread is executing that is not in our hand that totally depends on the operating system. In order to get the thread name that is executing currently there is a method in the Thread class currentThread() it is a native method (means its implementation is present in the operating system). It's return type is Thread.
Eg: Thread t = Thread.currentThread(); // will return the current thread reference that is executing.
t.getName(); // will give the name of the thread.

=> We can also do it like this 
System.out.println(Thread.currentThread().getName());

####################
‚ùÑÔ∏è Synchronization
####################
üëâ What is the need for Synchronization in our application ?
‚û§ Suppose there is a Bank class and we have an object of a Bank class now same object is performing withdraw and deposite at the same time this will cause the inconsistency in our data 
Eg: If we have 7k present in our bank and we withdraw 3k and deposit 5k at the same time then there is a chance that we either get the update balance as 4k after withdrawal or 12k after deposit which is wrong the correct balance should be 8k so to achieve this we need to make sure that first one of the transcation is completed then only other transaction takes place and to achieve this we need the synchronization .

‚û§ We can make a method synchronized by using keyword synchronized .
‚û§ When we want to make some work inside a method synchronized then we will use synchronized block .

#################
‚ùÑÔ∏è Object Lock 
#################
‚û§ Suppose T1 thread is executing a synchronized method m1() using object a of class A and T2 thread is trying to execute the methd m2() using same object a of class A so it wont be able to execute m2() because the object a is already executing the m1() so it has acquired objectLocka so it wont be able to execute another method .
‚û§ But if we create another object b then we will be able to execute the m2() because it has not acquired object lock so when it will execute m2() then it will acquire objectLockb.

‚û§ If methods were not synchronized then we can execute both method using the same object at the same time.
‚û§ So when we have instance method then object lock is acquired . Using object lock we make the instance data as Thread safe. 

‚û§ It is mechanism when we want to synchronize the non-static method or non static code block such that only one thread will be able to execute the code block on the given instance of the class 
‚û§ In object lock if one thread acquires the lock on object then any other thread cant access any other synchronized methods on the same object but they can access non synchronized methods. 
‚û§ So the synchronized methods in object lock are instance methods 
‚û§ If the threads are working on different object of a class then lock acquires on different objects 

#################
‚ùÑÔ∏è Class Lock 
#################
‚û§ Whereas if we want to make the class level data means static methods thread safe then we should go for class lock 
‚û§ In the above example if the synchronized methods are static methods then we don't need the object to call the static methods.
‚û§ When synchronized methods are static methods , then the lock that acquires is class lock.
‚û§ In class lock if one thread acquires the lock on class reference then any other thread cant access any other synchronized static methods on the same class reference until the first lock is released but they can access non synchronized static methods.

######################################
‚ùÑÔ∏è Difference between sleep and wait 
######################################
## sleep()
------------
‚û§ sleep() method is present in the thread class and it is a native static method.
Thread.sleep(10000);
‚û§ Whenever you are doing some transaction and some other resources are not responding then we use sleep() 
‚û§ This is a static method present in Thread class 
‚û§ Sleep accespts milli sec. Thread will sleep for specified time and after that starts the execution if system resource is not  busy. Whenever a thread is sleeping it will go to the runnable pool.
‚û§ Sleep doesn't release the lock .
‚û§ Sleep can be used with or without synchronized block.
‚û§ THread is used to pause the thread exection for some time 

## wait()
----------
‚û§ This is instance method present in Object class
‚û§ Thread will be in waiting status unless untill notify or notify all is called 
‚û§ Wait will release the lock 
‚û§ Wait can be used only with synchronized block . If used in non synchronized block then it throws illegal monitor state exception.
‚û§ Wait and notify or notify all are used for inter thread communication.

## notify() / notifyAll() 
--------------------------
‚û§ Using this method we let the thread that went to wait know that now you can execute if we dont notify then it will end up waiting for infinite number of time.
‚û§ So basically one thread has to talk to the other thread in order to tell it to come back to the execution and this is called as inter thread communication.
‚û§ notify() will notify only the single thread where as notifyAll() will notify all the threads that are waiting for that object.
‚û§ So what it means is suppose there is a kartik object which has 3 threads and 2 threads enter waiting mode and there is another object abc which entered waiting mode now a thread which is using kartik object calls notifyAll() so this method will notify to all the kartik objects not the abc object.
‚û§ Similarly when we use notify() then any one thread that is working on the same object will return back to the execution.

#################################################################################################
‚ùÑÔ∏è Why wait() notify() and notifyAll() is present in the Object class not in the Thread class ?
#################################################################################################
‚û§ Because they are used to control the behavior of threads that are accessing objects.
‚û§ In java threads execute code in the context of an object. When a thread accesses an object, it may need to wait for another thread to release the object's lock. This is where the wait(), notify() and notifyAll() methods come into play. 
‚û§ The wait(), notify() and notifyAll() methods allow threads to communicate and synchronize with each other when accessing shared objects. When a thread calls the wait() on an object, it releases the object's lock  and waits until another thread notifies it. When a thread calls the notify() method on an object, it wakes up one of the threads that are waiting on that objects monitor . When a thread calls the notifyAll() method on an object it wakes up all the threads that are waiting on that object's monitor. 
‚û§ Since the wait(), notify() and notifyAll() methods are used to control the behaviour of thread that are accessing objects, it makes sense to include these methods in the object class rather than the thread class. This way these methods can be used with any object that needs to be accessed by multiple threads, regardless of whether those threads are executing in the context of the same or different threads.

###################################
‚ùÑÔ∏è What is drawback of Threads ? 
###################################
‚û§ The drawback of a thread is that once a thread is dead we cant reuse that thread and in order to overcome this drawback of the threads we will use thread pool .

################
‚ùÑÔ∏è Thread Pool 
################
‚û§ It is mainly for re purpose of threads which are already created because on normal thread if you call start after completion on run method system throws illegal state exception. 
‚û§ In order to overcome the drawback of the thread the thread pool come in the java 1.5 
‚û§ Executor framework is used to configure the thread pool. 
‚û§ There are 4 thread pools : 
1. Single Thread Pool : Only one thread will be created in this and it will complete all the task 

2. Cached Thread Pool : You dont need to tell anything the schedular will start the thread if the thread is busy it will create one more thread like this it will keep on doing to complete the given task.
‚û§ So if threads are free then it will reuse the thread but if they are busy it will create a new thread.

3. Scheduled Thread Pool : It is a fixed thread pool but we can provide some delay.

4. Fixed Thread Pool : Based on our CPU a formula is used to find the max no of thread that we can create using thread pool 
maxPoolSize = processorCount * desiredThreadPool(Utilization) + overheadThreadCount. 
‚û§ So in this we provide fixed no of thread lets say 4 then we will complete the give task using this 4 threads only.
Ex: ExecutorService ex = Executors.newFixedThreadPool(3); //This will create fixed thread pool of 3 threads. 
//ExecutorService is an interface....