######################
‚ùÑÔ∏è What is Thread ?
######################
‚û§ Thread is an independent path of execution within a same program.
‚û§ There are 3 ways to create a thread 
1. Extends Thread class 
2. Implementing Runnable Interface

‚û§ start() method is responsible for creating the independent path of execution.
‚û§ The independent path of execution starts from the run() method.

##########################
‚ùÑÔ∏è Ways to create Thread 
##########################
‚û§ There are 3 ways to create a thread 
1. By extending Thread class 
2. By implementing runnable interface 
3. Implementing callable interface 

üëâ Extending Thread class 
***************************
‚û§ When we extend Thread class it will be calling the no args constructor of the Thread class from there we are getting the thread-ThreadNumber 
‚û§ So we are getting the thread number from there.
public Thread(){
    this(null, null, "Thread-"+nextThreadNum(), 0);
}
// The nextThreadNum() method is just incrementing the count of the threads and returning the thread number.
‚û§ In the Thread class there is a method called start() and this method is responsible to create the independent path of execution . So when we write t1.start() this will create the independent path of execution and start the exection of that from the run() method.
‚û§ So the starting point of every thread is run() method so we need to override it according to our need. If we dont override it then it will go to the run() of the thread class and run whatever is written inside the run() of Thread class.
‚û§ Calling the start() is not same as calling the run()
Eg: t1.start(); //This will create an independent path of execution and run the run().
t1.run(); //This will not create an independent path of execution will directly call the run() and execute it.
if we call the run() then it will not create the independent path of execution it will run the normally.
‚û§ If you want to keep the name for your thread then there are two ways to do it :

1. Using the constructor and passing name of thread while creating the object .
Eg: ThreadExample t1 = new ThreadExample("First Thread");

2. Using the setName() method 
Eg: t1.setName("asdf");
‚û§ We need to call the setName() before calling the start() always , it will not have any impact if we call it after the start() method. 

üëâ By implementing Runnable Interface 
****************************************
‚û§ Thread class internally implements the Runnable interface.
‚û§ The Runnable interface has only one abstract method run(). Which is overriden by the Thread class because it implements the runnable interface 
‚û§ So when we create thread using the runnable interface then we also need to override the run() method .
‚û§ Now we need to call the start() of the thread class and since it is an instance method we need to create thread class object first then only we can call the start() so how do we do this when we are creating a thread by implementing Runnable interface?? 
So we have a constructor in the Thread class which takes Runnable as parameter using this we will create the object of the thread class.
‚û§ We will create the object of the class that implemented Runnable interface and then we will pass it to the Thread class constructor this will create a Thread class object for us.

Example: 
----------
public class ThreadExampleUsingRunnable implements Runnable{

	@Override
	public void run() {
		// TODO Auto-generated method stub
		System.out.println("Hi");
	}
	
	public static void main(String[] args) {
		ThreadExampleUsingRunnable tr = new ThreadExampleUsingRunnable();
		Thread t = new Thread(tr);
		
		Thread t1 = new Thread(new ThreadExampleUsingRunnable());
		
		t.start();
		t1.start();
	}

}

##################
‚ùÑÔ∏è Thread States 
##################
‚û§ There are differnt states in threads 
1. New : A thread can be called to be in new state only when the thread object is created start() is not called yet.

üëâ NOTE: 
----------
‚û§ How many threads will run at a time will depend upon the operating system or our system configuration its not like that we have created 1000 threads and all threads will run at the same time it depends on the system.

2. Runnable : When we start the thread then we can say all the threads are in the runnable pool from there operating system will take some of the thread and will start running them .

3. Running : The thread which is executing the run() is said to be in the running state .

4. Dead : After the execution of the run() we can say that the thread is in the dead state.

5. Wait 
6. Sleep
7. Blocked 

üìÖ Can we use the same thread object multiple times ?
#######################################################
‚û§ So the basic idea here is that if a task takes 1 hr to be completed in a single thread and we want to reduce the execution time then we can take 20 threads and complete the same task in 20 min but the problem here is that we are creating 20 new thread objects which will occupy a lot of memory so to solve this problem.
‚û§ The thread object is free once it complete the execution of the run() so why dont we reuse that to solve this problem 
Eg: 
ThreadExample t1 = new ThreadExample("First Thread");
t1.start(); 
t1.start(); 
// But when we do this it will give us the illegalThreadState exception.
‚û§ So we are getting this execption because t1 has not yet finished the run() execution and how jvm knows this inside the start() there is a variable threadStatus which is checked everytime start() is called and it tells us about the status of the thread.
‚û§ So whenever we try to use a thread whose state is dead it will give us illegalThreadState exception. 
‚û§ So this means that we cant reuse the thread again .

‚û§ So the disadvantage of the thread is we cant reuse the thread object after the completion of run() method and in order to overcome this we are going to use thread pool.
‚û§ In normal thread we can't reuse the thread but using thread pool we can reuse the thread.

‚û§ At any point of time which thread is executing that is not in our hand that totally depends on the operating system. In order to get the thread name that is executing currently there is a method in the Thread class currentThread() it is a native method (means its implementation is present in the operating system). It's return type is Thread.
Eg: Thread t = Thread.currentThread(); // will return the current thread reference that is executing.
t.getName(); // will give the name of the thread.

=> We can also do it like this 
System.out.println(Thread.currentThread().getName());

####################
‚ùÑÔ∏è Synchronization
####################
üëâ What is the need for Synchronization in our application ?
**************************************************************
‚û§ Suppose there is a Bank class and we have an object of a Bank class now same object is performing withdraw and deposite at the same time this will cause the inconsistency in our data 
Eg: If we have 7k present in our bank and we withdraw 3k and deposit 5k at the same time then there is a chance that we either get the update balance as 4k after withdrawal or 12k after deposit which is wrong the correct balance should be 8k so to achieve this we need to make sure that first one of the transcation is completed then only other transaction takes place and to achieve this we need the synchronization .

‚û§ We can make a method synchronized by using keyword synchronized .
‚û§ When we want to make some work inside a method synchronized then we will use synchronized block .

#################
‚ùÑÔ∏è Object Lock 
#################
‚û§ Suppose T1 thread is executing a synchronized method m1() using object a of class A and T2 thread is trying to execute the method m2() using same object a of class A so it wont be able to execute m2() because the object a is already executing the m1() so it has acquired objectLocka so it wont be able to execute another method .
‚û§ But if we create another object b then we will be able to execute the m2() because it has not acquired object lock so when it will execute m2() then it will acquire objectLockb.

‚û§ If methods were not synchronized then we can execute both method using the same object at the same time.
‚û§ So when we have instance method then object lock is acquired . Using object lock we make the instance data as Thread safe. 

‚û§ It is mechanism when we want to synchronize the non-static method or non static code block such that only one thread will be able to execute the code block on the given instance of the class 
‚û§ In object lock if one thread acquires the lock on object then any other thread cant access any other synchronized methods on the same object but they can access non synchronized methods. 
‚û§ So the synchronized methods in object lock are instance methods 
‚û§ If the threads are working on different object of a class then lock acquires on different objects 

#################
‚ùÑÔ∏è Class Lock 
#################
‚û§ Whereas if we want to make the class level data means static methods thread safe then we should go for class lock 
‚û§ In the above example if the synchronized methods are static methods then we don't need the object to call the static methods.
‚û§ When synchronized methods are static methods , then the lock that acquires is class lock.
‚û§ In class lock if one thread acquires the lock on class reference then any other thread cant access any other synchronized static methods on the same class reference until the first lock is released but they can access non synchronized static methods.

######################################
‚ùÑÔ∏è Difference between sleep and wait 
######################################
## sleep()
------------
‚û§ sleep() method is present in the thread class and it is a native static method.
Thread.sleep(10000);
‚û§ Whenever you are doing some transaction and some other resources are not responding then we use sleep() 
‚û§ This is a static method present in Thread class 
‚û§ Sleep accespts milli sec. Thread will sleep for specified time and after that starts the execution if system resource is not  busy. Whenever a thread is sleeping it will go to the runnable pool.
‚û§ Sleep doesn't release the lock .
‚û§ Sleep can be used with or without synchronized block.
‚û§ THread is used to pause the thread exection for some time 

## wait()
----------
‚û§ This is instance method present in Object class
‚û§ Thread will be in waiting status unless untill notify or notify all is called 
‚û§ Wait will release the lock 
‚û§ Wait can be used only with synchronized block . If used in non synchronized block then it throws illegal monitor state exception.
‚û§ Wait and notify or notify all are used for inter thread communication.

## notify() / notifyAll() 
--------------------------
‚û§ Using this method we let the thread that went to wait know that now you can execute if we dont notify then it will end up waiting for infinite number of time.
‚û§ So basically one thread has to talk to the other thread in order to tell it to come back to the execution and this is called as inter thread communication.
‚û§ notify() will notify only the single thread where as notifyAll() will notify all the threads that are waiting for that object.
‚û§ So what it means is suppose there is a kartik object which has 3 threads and 2 threads enter waiting mode and there is another object abc which entered waiting mode now a thread which is using kartik object calls notifyAll() so this method will notify to all the kartik objects not the abc object.
‚û§ Similarly when we use notify() then any one thread that is working on the same object will return back to the execution.

#################################################################################################
‚ùÑÔ∏è Why wait() notify() and notifyAll() is present in the Object class not in the Thread class ?
#################################################################################################
‚û§ Because they are used to control the behavior of threads that are accessing objects.
‚û§ In java threads execute code in the context of an object. When a thread accesses an object, it may need to wait for another thread to release the object's lock. This is where the wait(), notify() and notifyAll() methods come into play. 
‚û§ The wait(), notify() and notifyAll() methods allow threads to communicate and synchronize with each other when accessing shared objects. When a thread calls the wait() on an object, it releases the object's lock  and waits until another thread notifies it. When a thread calls the notify() method on an object, it wakes up one of the threads that are waiting on that objects monitor . When a thread calls the notifyAll() method on an object it wakes up all the threads that are waiting on that object's monitor. 
‚û§ Since the wait(), notify() and notifyAll() methods are used to control the behaviour of thread that are accessing objects, it makes sense to include these methods in the object class rather than the thread class. This way these methods can be used with any object that needs to be accessed by multiple threads, regardless of whether those threads are executing in the context of the same or different threads.

###################################
‚ùÑÔ∏è What is drawback of Threads ? 
###################################
‚û§ The drawback of a thread is that once a thread is dead we cant reuse that thread and in order to overcome this drawback of the threads we will use thread pool .

################
‚ùÑÔ∏è Thread Pool 
################
‚û§ It is mainly for re purpose of threads which are already created because on normal thread if you call start after completion on run method system throws illegal state exception. 
‚û§ In order to overcome the drawback of the thread the thread pool come in the java 1.5 
‚û§ Executor framework is used to configure the thread pool. 
‚û§ There are 4 thread pools : 
1. Single Thread Pool : Only one thread will be created in this and it will complete all the task 

2. Cached Thread Pool : You dont need to tell anything the schedular will start the thread if the thread is busy it will create one more thread like this it will keep on doing to complete the given task.
‚û§ So if threads are free then it will reuse the thread but if they are busy it will create a new thread.

3. Scheduled Thread Pool : It is a fixed thread pool but we can provide some delay.
‚û§ It is also a type of a fixed thread pool but the only change is that you can schedule some fixed time.
‚û§ We use ScheduledTheadPool when we want to start a process after a certain time .
Ex: String s = display();
List<ScheduledFuture<Object>> l = new ArrayList();
ScheduledExecutorService ex1 = Executors.newScheduledThreadPool(2);
for(int i=0; i<customerList.Size(); i++){
	TriggerEmailForPolicy t = new TriggerEmailForPolicy(customeList.get(i));
	ScheduledFuture<Object> tx = ex1.schedule(t, 2, TimeUnit.MINUTES);
	l.add(tx);
}
// So for above code two threads will be created and every thread will take 2 min after its created to execute.

‚û§ So here the schedule() will create the delay and then start the execution.
‚û§ In this schedule() method is responsible for creating the independent path of execution.
‚û§ Thread will be created but the execution of thread will start after the 2 min for above code 

üëâ When we use schedule(t,2,TimeUnit.MINUTES;) then 
‚û§ So what is happening is after completion of the work T1 will wait for 2 min and then it will take another work from the queue like this delay is working.

üëâ When we use scheduleAtFixedRate(t, 2, 10, TimeUnit.MINUTES);
‚û§ So here what will happen is for the first time the thread will execute after the 2min then from the second time onwards it will take 2 + 10 = 12min to start the execution.

‚û§ The return type of all the schedule() method is ScheduledFuture.

üåü Now to reuse the data that we have got from the run() 
----------------------------------------------------------
for(int i=0; i<l.size(); i++){
	ScheduledFuture<Object> ob = l.get(i);
	// ob.isDone(); //this method will give us the result as true if the thread execution has been done successfully else it will give false 
	// So we will check first for each ob that the exection is done or not then only we will use get() 
	if(l.get(i).isDone()){
		try{
			System.out.println(l.get(i).get());
		}catch(InterruptedException | ExecutionException e){
			e.printStackTrace();

		}
	}
}

4. Fixed Thread Pool : Based on our CPU a formula is used to find the max no of thread that we can create using thread pool 
maxPoolSize = processorCount * desiredThreadPool(Utilization) + overheadThreadCount. 
‚û§ So in this we provide fixed no of thread lets say 4 then we will complete the give task using this 4 threads only.
Ex: ExecutorService ex = Executors.newFixedThreadPool(3); //This will create fixed thread pool of 3 threads. 
//ExecutorService is an interface....
‚û§ Whenever you use ExecutorService submit() or execute() method is responsible for creating the independent path of execution.
‚û§ Internally the thread pool uses the queue concept.
Example: 
--------
public class MultiThreadingForInsurance {

	public static void main(String[] args) {
		Customer c = new Customer("Kartik", "PL1234", 100000.00);
		Customer c1 = new Customer("Harish", "PL1252", 50000.00);
		Customer c2= new Customer("Ram", "PL1265", 200000.00);
		Customer c3 = new Customer("Raju", "PL1276", 30000.00);
		Customer c4 = new Customer("Ravi", "PL1223", 60000.00);
		Customer c5 = new Customer("Pintu", "PL1298", 300000.00);
		Customer c6 = new Customer("Tiklup", "PL1243", 500000.00);
		Customer c7 = new Customer("Tilak ", "PL1209", 110000.00);
		
		List<Customer> customerList = new ArrayList<>();
		customerList.add(c);
		customerList.add(c1);
		customerList.add(c2);
		customerList.add(c3);
		customerList.add(c4);
		customerList.add(c5);
		customerList.add(c6);
		customerList.add(c7);
		
		ExecutorService ex = Executors.newFixedThreadPool(3);
		
		for(int i=0; i<customerList.size(); i++) {
			ex.execute(new TriggerEmailForPolicy(customerList.get(i)));
			
		}
		// Since the thread pool uses queue so threads will be assigned to the customer objects in a FIFO manner.
		
		// So here if we fetch data like this then it will take 10hrs let us suppose 
		// So we will use thread pool here with 4 threads so time will reduce to 2.5 because all the threads are running parallel

	}
	
	public static void triggerEmail() {
		 
	}
}
‚û§ So here execute method will create an independent path of execution. 

‚û§ So here the first thread after the execution of the run() method it will take the task from the queue.
‚û§ It will complete the task and then remove it from the queue each time after completing the task the thread will check the queue.size() if it is 0 then the thread will understand that all the task are completed.
‚û§ So here even after the completion of the program the thread is alive that is how it is managing to reuse the thread because once the thread is dead then we cant reuse it , it will give us illegal thread state exception.
‚û§ So we need to shutdown the thread before the execution of the program is completed so we will do 
ex.shutdown()
‚û§ So in order to kill the thread we need to call the shutdown() method.

‚û§ Internally it is using the LinkedBlockingQueue
‚û§ All the objects will go to the queue and wait for there turn when the execution of an object is completed then the thread will move to the next object.

################################################
‚ùÑÔ∏è Drawback of the run() of Runnable Interface 
################################################
‚û§ The drawback of the run() is that we cant return anything from the run() method because its return type is void  in the runnable interface.
‚û§ So we can say that the drawback of the Runnable interface is that whenever we are using run() we cant return anything from that run() method.
‚û§ But if you want to return something from the run() then you should Implement Callable interface 
‚û§ Callable inteface takes generic in which we can pass the return type that we want. It has an abstract method call() whose return type is the same as the type that we give to our callable interface.
‚û§ So instead of impelementing Runnable Interface we will implement Callable Interface whenever we want to return something from run().
‚û§ With callable Interface we need to use ex.submit() it takes callable object but ex.execute() takes runnable object.
‚û§ submit() in the Executor framework can take both Runnable and Callable object whereas execute() can take only Runnable object.

#####################
‚ùÑÔ∏è Future Interface 
#####################
‚û§ In order to accept some data or object that comes in future whenever we do multithreading programming this interface is used.
‚û§ Basically it is a placeholder that is use to capture or store the object that is coming in future.
‚û§ So when we implement Callable interface then the call method will return some value after the thread is executed so to hold this method we need to store it in the the Future interface reference variable 
‚û§ Because as the thread is keep on executing the task of the queue one by one we dont know which of value is for which task so to store this we need to use the Future interface.

Ex: 
String s = display();
ExecutorService ex = Executors.newFixedThreadPool(3);
List l = new ArrayList();
for(int i=0; i<customerList.size(); i++){
	TriggerEmailForPolicy t = new TriggerEmailForPolicy();
	Future<Object> obj = ex.submit(t);
	l.add(obj);
}

########################################################
‚ùÑÔ∏è How can we set the name in the Executor Framework ?
########################################################
‚û§ So we will pass the second parameter to the constructor of the Executors.newFixedThreadPool(0,)
// The second argument is a ThreadFactory interface so we have to implement it and using this we will be able to give name to our threads.

Ex: ExecutorService ex = Executors. newFixedThreadPool(2, new ThreadFactory(){
	int counter = 0;
	@Override 
	public Thread newThread(Runnable r){
		Thread t = new Thread(r);
		t.setName("Thread"+counter++);
		return t;
	}
});

‚û§ So here instead of implementing the interface separately we have created an anonymous class and there we have overriden the method of the ThreadFactory interface. 

##################################################################################
‚ùÑÔ∏è  What is the difference between synchronized method and synchronized block ?
##################################################################################
‚û§ In synchronized method once the lock is acquired then it will be release only after the execution of that method.
‚û§ In synchronized block the lock is acquire within the method an synchronized block is created and it can be released before the execution of the entire method.

Example: 
	synchronized void display(SynchronizedExample d) {
		System.out.println("Hi1");
		System.out.println("Hi2");
		System.out.println("Hi3");
		System.out.println("Hi4");
	}
	// When display method will start executing it will acquire the lock then no other thread will be able to execute display method 
	// They will enter into the waiting mode.
	
	void display1(SynchronizedExample d) {
		System.out.println("hi 1");
	 	System.out.println("hi 2");
	 	synchronized(d) {
	 		System.out.println("hi3");
	 		System.out.println("hi4");
	 	}
	}
	// Here other thread can also start executing the display1() and they can execute the upper two lines then they have to wait for the lock to be release.

üëâ How to override the run() method of the Runnable interface using lambda?
‚û§ So we can write the implemetation of the unimplemented method of an interface using lambdas we can do this for the interface with only one abstract method.
‚û§ So we will create the reference variable of the interface and then we will implement the unimplemented method like give below.
Ex: Runnable l1 = () -> {
	s.display(s);
}

‚û§ We can also create thread object like this : 
Thread t = new Thread(() -> s.display(s)); 

üåü Drawback of synchronized 
*****************************
‚û§ So suppose there are three threads T1 T2 and T3 , thread T1 has acquired the lock now both thread T2 and T3 will go into the waiting mode so now we suppose T2 is waiting for longer period of time so it should get the lock firt but we can say that for sure that it will get to acquire the lock first and execute run(). This is one of the drawback of threads . 
‚û§ So basically there are two types of lock 
1. Fair Lock : In this the thread that has been waiting for a longer period of time will acquire the lock first .

2. Unfair Lock : In this we cant say that the thread that is waiting for longer period will get the lock first it may get or it might not get the lock for the longer period of time.

‚û§ Let us take a scenario when we enter the display() it will acquire the lock and we want it to release the lock when we enter the display1() and when we execute the second line hi 2 is printed we want to relase the lock can this happen using the synchronized keyword ?

synchronized void display(SynchronizedExample d) {
	//Lock is acquired here 
		display1(s);
		System.out.println("Hi1");
		System.out.println("Hi2");
		System.out.println("Hi3");
		System.out.println("Hi4");
	}
	
	void display1(SynchronizedExample d) {
		System.out.println("hi 1");
	 	System.out.println("hi 2");
		//We want it to release the lock here.
	 	synchronized(d) {
	 		System.out.println("hi3");
	 		System.out.println("hi4");
	 	}
	}
‚û§ So no this is not possible using the synchronized keyword because synchronized keyword can be used to a method or within the method. We cant use synchronized keyword across the method.
‚û§ So this is also one of the drawback

üëâ So in order to overcome this we will go for a Lock .

###################
‚ùÑÔ∏è Lock Interface 
###################
‚û§ In java we have a Lock interface present in java.util.concurrent.locks package. It has a lock() using which it will acquire the lock. And there is also an unlock() method which is used to relase the lock. 
‚û§ To use this lock interface we need to provide the implementation for these two methods but we dont know the how to implement these two methods
‚û§ So in java under the lock mechanism there is a class ReentrantLock .
‚û§ So for Lock interface ReentrantLock class and ReentrantReadWriteLock provides the implementation for its unimplemented methods.
‚û§ Whenever you want to use Lock interface create its object like this
Lock l = new ReentrantLock();
Lock l1 = new ReentrantReadWriteLock(); 

Example: 
synchronized void display(LockExample1 d) {
		//CreateLock
		l.lock();
		System.out.println("Hi1");
		System.out.println("Hi2");
		System.out.println("Hi3");
		System.out.println("Hi4");
		l.unlock();
	}

	public static void main(String[] args) {
		LockExample1 l1= new LockExample1();
		Thread t = new Thread(()-> l1.display(l1));
		Thread t1 = new Thread(()-> l1.display(l1));
		Thread t2= new Thread(()-> l1.display(l1));
		Thread t3 = new Thread(()-> l1.display(l1));
		
		t.start();
		t1.start();
		t2.start();
		t3.start();
		
	}
‚û§ It will behave the same when one thread will acquire the lock the other threads have to wait.
‚û§ Here by using this lock interface we can make some changes in our Reentrant class lock method to make sure that the thread which is waiting for longer period of time gets the lock first . So this solves one of the problem or drawback of the synchronized keyword.
‚û§ So based on the waiting time of the thread we want to do acquire the lock. 
‚û§ We can also acquire the lock in one method and then release it in another method using this lock() and unlock()
‚û§ Using lock we are able to achieve or solve both the problems that we were facing in the synchronized block or method.
‚û§ If we forget to unlock then the lock will stay on forever suppose an exception occured during lock so lock will not be relased , so to avoid these kind of scenarios we write unlock() inside the finally block.
Eg: 
lock.writeLock().lock();
try{
	if(balance >= amount){
		balance -= amount;
	}else{
		throw new IllegalArgumentException("Mssg here");
	}
}finally {
	lock.writeLock().unlock();
}

üëâ How we can do this?
========================= 
‚û§ We will pass true as an argument to the ReentrantLock it has a constructor. 
public ReentrantLock(boolean fair){
	sync = fair ? new FairSync() : new NonFairSync();
} 
// If we give the value as true then it make the lock realse mechanism as fair which means the the thread which was waiting for longer period of time will acquire the lock first. If false then it will behave as normal any thread can get the lock we cant say for sure that the thread that is waiting for longer period of time will get the lock.
// So by not passing any argument or passing false as an argument the behaviour will be same.

############################
‚ùÑÔ∏è ReadWriteLock interface 
############################
‚û§ It is present in java.util.concurrent.locks it contains two methods 
1. readLock() : 
=> It returns the lock for reading 

2. writeLock() :
=> It returns the lock for writing. 

‚û§ The ReentrantReadWriteLock class provides the implementation for this interface.

‚û§ Suppose we have Bank class with some methods  checkBalanceUsingUPI ,checkBalanceUsingMobileApp, checkBalanceUsingNetBanking so these three method can be executed together means we can check balance using all three at the same time so here we will use readLock() to acquire this will allow all three to acquire lock
‚û§ And we have deposit and witdraw methods here read and write both operations will take place so here we will acquire writeLock() this will allow only one of the thread to acquire the lock other thread will wait to acquire the lock till the lock is rlease.  

// Implementation of writeLock() 
----------------------------------
ReentrantReadWriteLock l = new ReentrantReadWriteLock();
void withDraw(double withdrawAmt){
	l.writeLock().lock();
	amount = amount - withdrawAmt;
	l.writeLock().unlock();
}

// Implementation of readLock()
---------------------------------
ReentrantReadWriteLock l = new ReentrantReadWriteLock();
void balanceInquiryFromUPI(){
	l.readLock().lock();
	System.out.println("Balance is "+amount);
	l.readLock().unlock();
}

üëâ Advantage
=============== 
‚û§ So whenever multiple threads are executing the read operation then they can do it at the same time.
‚û§ But when they are executing the performing the write operation then they will not execute the same time one thread will acquire the lock and other threads will wait for the lock to be released.

üëâ Disadvantage of lock 
=========================
‚û§ The disadvantage of lock is that locking and unlocking is in developers hand so there is a chance that they might forget to unlock the lock or due to some exception the unlock doesnt happens  which will make the lock for infinite time. 
‚û§ So it is better to write unlock inside the finally because everything written inside this block will get executed everytime even if the execution occurs then also.

##############
‚ùÑÔ∏è Volatile 
##############
‚û§ As we know that each thread have independent path of execution and they cant see what the other thread is doing the problem here is suppose both the threads are performing some operation and updating the value of a same variable so both needs to know what is the updated value 
‚û§ If they dont then there will be inconsistency in the data. 
Eg: 
int i = 5;
T1 thread 
i = i+10; 

T2 thread 
i = i+20;

‚û§ So here both are perfoming some operation on the same variable if this is a scenario we can do it by making it synchronized but when we have multiple threads then what happen
‚û§ So there is a thread cache memory for each of the thread both threads will have thread cache but both threads cant see the data of each other 
‚û§ So when we want the data of a variable to be accessed but other threads then we make that variable as volatile 
Eg: volatile int i = 5;

‚û§ Volatile is the keyword and it is used only on the global variable.
When we make a variable volatile then it is immediately pushed form thread cache to main memory so now the other thread can access the updated data. 

#######################################################
‚ùÑÔ∏è What is difference between volatile and transient?
#######################################################
‚û§ Volatile is realted to the threads concept where as transient is related to the serialization concept.
‚û§ Volatile keyword is used when we want to make a variable data accessible to all the threads it means as soon as the data of the variable is upated it is immediately pushed from the thread cache to main memory so that other thread can access the updated data.

‚û§ So in serialization we spilt the data into bytes and send it over a network and then when data is received it is deserialized 
‚û§ So suppose that there is some data lets say password that we dont waana deserialize then we add transient keyword in front of that variable 
‚û§ So whenever we add transient keyword in front of the variable then that variable wont be serialized.

##########################
‚ùÑÔ∏è What is a Deadlock ?
##########################
‚û§ When each thread is waiting for other thread to release the lock then deadlock occurs. 

üå¨Ô∏è Ways to avoid deadlock 
***************************
üëâ By keeping the order of acquiring the lock same 
----------------------------------------------------
‚û§ If the order or acquiring the lock is same then it wont be a problem deadlock wont occur but if the order is different then the deadlock might occur. This is one of the way of avoiding deadlock.
‚û§ When we use synchronized keyword then we cant tell for sure if the lock is acquired or it is free so if it is already acquired then the thread will go on to the wait mode .

üëâ Using trylock() 
--------------------
‚û§ tryLock() method will first check if the lock is available then only it will acquire the lock else it will not acquire the lock.
‚û§ But using lock() we can check if the lock is already acquired or not. 
‚û§ Using tryLock() method present in the lock interface it will return true if the lock is available if it is not available then it will return false .
Eg: l.lock(); //lock acquried
if(l.tryLock()){ //returns false

}
else{

}
// For the above case since the lock is already acquired so it will execute the else part.
‚û§ It will acquire the lock if it is free so when ever tryLock() method returns true it means that the lock is acquried

üëâ Using semaphore 
---------------------
‚û§ Whenever you want to restrict the access for the the shared resource then we will go for semaphore.
‚û§ The semaphore class has a constructor which takes permits as agrument what this permits is we provide the value to this and this will allow that many threads to  will be able to execute the shared resource .
‚û§ In the semaphore class semaphore.acquire() will acquire the lock and semaphore.release() will release the lock.
Eg: 
private static Semaphore semaphore = new Semaphore(2);
public void run(){
	try{
		System.out.println("Thread "+id+" is waiting for a permit.");
		semaphore.acquire();
		System.out.println("Thread "+id+" has acquired the permit.");
		Thread.sleep(10000);
		semaphore.release();
		System.out.println("Thread "+id+" has released a permit");
	}
}
// Will allow two threads to execute the shared resource.

‚û§ Semaphore in java is a synchronization mechanism that allows a fixed number of threads to access a shared resource at the same time. It maintains a count of the number of permits available and each thread that wants to access the shared resouce must acquire a permit from the semaphore. If no permits are available the thread will block until a permit becomes available. 
‚û§ So using semaphore though the threads are working on the different object we can still control how many thread we want to access shared resource at a time. 

###################
‚ùÑÔ∏è join() method 
###################
‚û§ When two threads are running parallely and we want one thread to execute fully first and then the other thread should execute thats where the join method comes into picture. 
Eg: public static void main(String[] args) {
		Thread t = new Thread(new Runnable() {

			@Override
			public void run() {

				System.out.println("Run method executed");
			}
			
		});
		t.start();
		t.join();
		System.out.println("Hiii");
		System.out.println("Hello");
	}
// Here in above example main thread and thread t are running parallely and we want t thread to execute first then main thread shoudl execute . 
// When we give t.join() then the parent of thread t that is main thread will wait untill the thread t is executed.
‚û§ So until the t thread is executed the main thread will go onto the wait mode. It will come into the execution when the run method is executed fully by the thread t.

‚û§ Suppose there are two processes p1 and p2 and p2 is dependent on p1 so p1 needs to finish first then only p2 can execute here we cant do multithreading otherwise we will get the wrong answers so wherever there is a dependency like this then we will use join() method we will write p1.join() then we will write the code for p2 this will make sure that first the p1 process is executed and then the p2 process will execute 

‚û§ The above example will wait for single thread to complete but in case of multithreading we use executors framework there we want multiple threads to wait in this case what will we do??

‚òÉÔ∏è For multiple threads (Executors Framework)
-----------------------------------------------
‚û§ public static void main(String[] args) {
		ExecutorService ex = Executors.newFixedThreadPool(3);
		
		for(int i=0; i<10; i++) {
			ex.execute(new Runnable() {

				@Override
				public void run() {
					System.out.println("Hi "+Thread.currentThread());
				}
				
			});
		}
	}
‚û§ Here using the three threads we are performing 10 tasks so we want main thread to execute after all these threads are executed so here we cant use the join() this is one of the drawback of the join() method 
‚û§ We cant use join() method for multiple thread execution.
‚û§ So there is a class called CountDownLatch using this we can solve this problem 
Eg: 
static CountDownLatch c = new CountDownLatch(10);
	public static void main(String[] args) throws InterruptedException {
		ExecutorService ex = Executors.newFixedThreadPool(3);
		
		for(int i=0; i<10; i++) {
			ex.execute(new Runnable() {

				@Override
				public void run() {
					System.out.println("Hi "+Thread.currentThread());
					c.countDown();
				}
			});
		}
		c.await();
		System.out.println("Hiii...");
		System.out.println("Hellooo...");
	} 
‚û§ The await() method will know if the all the threads are completed or not based on the countdown if the countdown is 10 that means the threads have completed the task.
‚û§ The await() method will wait till all the tasks are completed so this is how we will do it in multithreading. Now in above example the main thread will wait till all the threads are executed.
‚û§ So CountDownLatch will make sure all the threads are executed before it executes the next task.

##############
‚ùÑÔ∏è Atomicity 
##############
‚û§ Atomicity is at any point of time only one thread will execute without having synchronized block or lock mechanism or semaphore.
‚û§ In multithreading program it is possible for multiple threads to access and modify the same variable concurrently. When multiple threads modify a variable concurrently there is a possiblility of data races which can result in incorrect or unpredictable behaviour of the program.
‚û§ To avoid the data races we need a way to ensure that a variable is accessed and modified atomically i.e; by a single thread at a time. This is where atomic variables come in . Atomic variables provide a way to modify a variable atomically without the need for locks or other synchronization mechanisms. 
‚û§ An atomic variable is a variable that is updated atomically i.e in a way that ensures that no other thread can modify the variable at the same time. In java atomic variables are provided by the java.util.concurrent.atomic package. Some common examples of atomic variables are AtomicInteger and AtomicBoolean 
‚û§ When we use synchronized block there is no issue to variables because one thread will work at a time on same object but when there is no synchronized block multiple threads can execute multiple methods on same object and the value of one variable is not visible to other thread. So in this scenario we can use atomic variable instead of normal variable that means atomic can be more effective when there is no synchronized or lock mechanism.
‚û§ When we use a synchronized block only one thread can execute the block at a time which ensures that there are no data races on shared variables so if all accesses to shared variables are within synchronized blocks then we dont need to use atomic variables.

#####################################################
‚ùÑÔ∏è Difference between volatile and atomic variable 
#####################################################
‚û§ Volatile will solve the problem of visibility it will only let the other threads know the updated value but the problem that when two threads will execute the output will be different still exists 
‚û§ This problem is solved by atomic variable.
‚û§ Volatile and atomic variables both used in java for concurrent programming but they differ in how they provide thread safety
‚û§ Volatile variables provide a way to ensure that the variable's value is always read from and written to main memory, rather than from a thread's local cache. This ensures that changes made to the variable by one thread are visible to all other threads immediately. However, volatile variables don't ensure atomicity, i.e they do not ensure that multiple threads accessing the variable do so atomically. If multiple threads modify a volatile variable concurrently there is still a risk of data races and other concurrency issues. 
‚û§ On the other hand atomic variables provide a way to ensure that operations on the variable are atomic i.e; thread safe. They enusre that multiple threads can modify the variable concurrently without causing data races. Atomic variables are implemented using low level CPU instructions to ensure that the variable is accessed and modified atomically. 
‚û§ They difference between volatile and atomic variables is that volatile variables provide visibility guarantees i.e; they ensure that changes made to the variable by one thread are immediately visible to other threads . Atomic cariables on the other hand provide both visibility and atomicity guarantees i.e; they ensure that operations on the variable are thread safe. 